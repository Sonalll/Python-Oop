# -*- coding: utf-8 -*-
"""Python OOPs Assignment

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xUpa7MPVO54_PJRGOJC43HtVaQ5VTJ6p
"""





"""Ans 1) Object-Oriented Programming (OOP) is a paradigm based on the concept of "objects," which contain data and methods. The five key concepts of OOP are:

Encapsulation

Definition: Bundling data (attributes) and methods (functions) that operate on the data into a single unit, typically a class. Encapsulation also involves restricting direct access to some of the object's components, which is achieved through access modifiers like private, protected, and public.
Purpose: Protects the integrity of the data and promotes modular design by exposing only necessary parts of an object.
Abstraction

Definition: Hiding complex implementation details and exposing only the necessary functionality of an object. Abstraction focuses on what an object does rather than how it does it.
Purpose: Simplifies design and makes it easier to work with large systems by reducing complexity.
Inheritance

Definition: A mechanism where one class (the child or subclass) derives properties and behaviors from another class (the parent or superclass). Inheritance allows code reuse and establishes a hierarchical relationship between classes.
Purpose: Promotes code reusability and helps model real-world relationships.
Polymorphism

Definition: The ability of different objects to respond uniquely to the same method or operation. This can be achieved through method overloading (compile-time polymorphism) or method overriding (runtime polymorphism).
Purpose: Increases flexibility and allows the same interface to represent different underlying forms (e.g., multiple shapes implementing a common draw() method).
Composition (or Association)

Definition: Building complex objects by combining simpler objects or classes. Unlike inheritance, composition involves creating relationships where objects are used as components rather than extending a base class.
Purpose: Promotes code modularity and flexibility by creating loosely coupled systems where parts can be replaced or updated independently.
These principles form the foundation of OOP and help developers build scalable, maintainable, and reusable software.







"""

// Ans 2)
class Car:
    def __init__(self, make, model, year):
        """
        Initializes a new Car instance.

        :param make: The manufacturer of the car (e.g., 'Toyota').
        :param model: The model of the car (e.g., 'Camry').
        :param year: The production year of the car (e.g., 2022).
        """
        self.make = make
        self.model = model
        self.year = year

    def display_info(self):
        """
        Displays the car's information in a formatted string.
        """
        print(f"Car Information: {self.year} {self.make} {self.model}")

"""// Ans 3) In Python, instance methods and class methods are two types of methods that differ in their behavior, how they are accessed, and what they operate on. Here’s a breakdown of their differences and examples:

Instance Methods
Definition: Methods that operate on individual instances of a class.
Access: Require an instance of the class to be called.
Behavior: Have access to the instance (via self) and can access or modify instance attributes.
Use case: Perform operations related to a specific object.
Example of an Instance Method:
class Dog:
    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    def bark(self):
        print(f"{self.name} says Woof!")

# Example usage
dog = Dog("Buddy", "Golden Retriever")
dog.bark()  # Output: Buddy says Woof!

Class Methods
Definition: Methods that operate on the class itself rather than instances.
Access: Called on the class rather than an instance, and use cls (class reference) as their first parameter.
Behavior: Cannot access instance attributes directly but can modify class-level attributes or perform operations relevant to the class as a whole.
Use case: Define behavior that applies to the entire class, such as factory methods or maintaining class-level state.
Example of a Class Method:
class Dog:
    species = "Canis lupus familiaris"  # Class-level attribute

    def __init__(self, name, breed):
        self.name = name
        self.breed = breed

    @classmethod
    def set_species(cls, new_species):
        cls.species = new_species

# Example usage
Dog.set_species("Canis lupus")  # Change the class-level species
print(Dog.species)  # Output: Canis lupus

Ans 4) Python does not natively support method overloading in the way languages like Java or C++ do. Instead, Python achieves similar functionality using default arguments, variable arguments (*args, **kwargs), or by explicitly checking the argument types and counts within a single method.

This flexibility stems from Python’s dynamic nature, where methods can accept a variable number of arguments and perform different operations based on the input.

Example: Using Default Arguments

class Calculator:
    def add(self, a, b=0, c=0):
        '''
        Adds one, two, or three numbers.
        :param a: First number (required).
        :param b: Second number (default is 0).
        :param c: Third number (default is 0).
        :return: Sum of the numbers.
        '''
        return a + b + c

# Example usage
calc = Calculator()
print(calc.add(5))         # Single argument: 5 + 0 + 0 = 5
print(calc.add(5, 10))     # Two arguments: 5 + 10 + 0 = 15
print(calc.add(5, 10, 20)) # Three arguments: 5 + 10 + 20 = 35

Example: Using Variable Arguments (*args)
python
class Calculator:
    def add(self, *args):
        '''
        Adds a variable number of numbers.
        :param args: A tuple of numbers to sum up.
        :return: The sum of the numbers.
        '''
        return sum(args)

# Example usage
calc = Calculator()
print(calc.add(5))          # Output: 5
print(calc.add(5, 10))      # Output: 15
print(calc.add(5, 10, 20))  # Output: 35
Example: Using Type or Argument Checks
python
class Printer:
    def print_value(self, value):
        if isinstance(value, int):
            print(f"Integer: {value}")
        elif isinstance(value, str):
            print(f"String: '{value}'")
        else:
            print("Unsupported type")

# Example usage
printer = Printer()
printer.print_value(42)          # Output: Integer: 42
printer.print_value("Hello")     # Output: String: 'Hello'
printer.print_value([1, 2, 3])   # Output: Unsupported type

In Python, access modifiers control the visibility and accessibility of class members (attributes and methods). Unlike some languages like Java or C++, Python doesn't enforce strict access control but provides conventions and naming schemes to indicate access levels. These access modifiers are:

1. Public
Definition: Members that are accessible from anywhere (inside or outside the class).
Denotation: No special prefix is used; the member is defined normally.
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self.name = "Public Member"  # Public attribute

    def display(self):
        print(self.name)  # Public method

obj = MyClass()
print(obj.name)  # Accessible
obj.display()    # Accessible
2. Protected
Definition: Members that are intended to be accessed only within the class and its subclasses. This is a convention, not a strict rule, as Python doesn't enforce it.
Denotation: A single underscore _ prefix (e.g., _protected_member).
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self._name = "Protected Member"  # Protected attribute

    def _display(self):  # Protected method
        print(self._name)

class SubClass(MyClass):
    def show(self):
        print(self._name)  # Accessible in subclass

obj = SubClass()
obj.show()         # Accessible
print(obj._name)   # Still accessible but should be avoided
3. Private
Definition: Members that are intended to be accessed only within the class itself. Python enforces this by name mangling, which changes the name of the private member to include the class name as a prefix.
Denotation: A double underscore __ prefix (e.g., __private_member).
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self.__name = "Private Member"  # Private attribute

    def __display(self):  # Private method
        print(self.__name)

    def access_private(self):  # Method to access private member
        self.__display()

obj = MyClass()
# print(obj.__name)       # Error: Attribute not accessible directly
obj.access_private()      # Allowed through a public method
Note: Private members can still be accessed using name mangling:

python
Copy code
print(obj._MyClass__name)  # Access private attribute
However, this practice is discouraged as it breaks the intended encapsulation.

// Ans 5) In Python, access modifiers control the visibility and accessibility of class members (attributes and methods). Unlike some languages like Java or C++, Python doesn't enforce strict access control but provides conventions and naming schemes to indicate access levels. These access modifiers are:

1. Public
Definition: Members that are accessible from anywhere (inside or outside the class).
Denotation: No special prefix is used; the member is defined normally.
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self.name = "Public Member"  # Public attribute

    def display(self):
        print(self.name)  # Public method

obj = MyClass()
print(obj.name)  # Accessible
obj.display()    # Accessible
2. Protected
Definition: Members that are intended to be accessed only within the class and its subclasses. This is a convention, not a strict rule, as Python doesn't enforce it.
Denotation: A single underscore _ prefix (e.g., _protected_member).
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self._name = "Protected Member"  # Protected attribute

    def _display(self):  # Protected method
        print(self._name)

class SubClass(MyClass):
    def show(self):
        print(self._name)  # Accessible in subclass

obj = SubClass()
obj.show()         # Accessible
print(obj._name)   # Still accessible but should be avoided
3. Private
Definition: Members that are intended to be accessed only within the class itself. Python enforces this by name mangling, which changes the name of the private member to include the class name as a prefix.
Denotation: A double underscore __ prefix (e.g., __private_member).
Example:
python
Copy code
class MyClass:
    def __init__(self):
        self.__name = "Private Member"  # Private attribute

    def __display(self):  # Private method
        print(self.__name)

    def access_private(self):  # Method to access private member
        self.__display()

obj = MyClass()
# print(obj.__name)       # Error: Attribute not accessible directly
obj.access_private()      # Allowed through a public method
Note: Private members can still be accessed using name mangling:

python
Copy code
print(obj._MyClass__name)  # Access private attribute
However, this practice is discouraged as it breaks the intended encapsulation.

//Ans 6
Inheritance in Python allows a class (child class) to acquire properties and behaviors from another class (parent class). There are five types of inheritance in Python:

1. Single Inheritance
Definition: A child class inherits from a single parent class.
Example:
python

class Parent:
    def greet(self):
        print("Hello from Parent")

class Child(Parent):
    def greet_child(self):
        print("Hello from Child")

obj = Child()
obj.greet()        # Output: Hello from Parent
obj.greet_child()  # Output: Hello from Child
2. Multiple Inheritance
Definition: A child class inherits from two or more parent classes.
Example:
python

class Parent1:
    def greet1(self):
        print("Hello from Parent1")

class Parent2:
    def greet2(self):
        print("Hello from Parent2")

class Child(Parent1, Parent2):
    def greet_child(self):
        print("Hello from Child")

obj = Child()
obj.greet1()       # Output: Hello from Parent1
obj.greet2()       # Output: Hello from Parent2
obj.greet_child()  # Output: Hello from Child
3. Multilevel Inheritance
Definition: A class inherits from a parent class, and another class inherits from this child class, forming a chain.
Example:
python

class GrandParent:
    def greet_grandparent(self):
        print("Hello from GrandParent")

class Parent(GrandParent):
    def greet_parent(self):
        print("Hello from Parent")

class Child(Parent):
    def greet_child(self):
        print("Hello from Child")

obj = Child()
obj.greet_grandparent()  # Output: Hello from GrandParent
obj.greet_parent()       # Output: Hello from Parent
obj.greet_child()        # Output: Hello from Child
4. Hierarchical Inheritance
Definition: Multiple child classes inherit from a single parent class.
Example:
python

class Parent:
    def greet(self):
        print("Hello from Parent")

class Child1(Parent):
    def greet_child1(self):
        print("Hello from Child1")

class Child2(Parent):
    def greet_child2(self):
        print("Hello from Child2")

obj1 = Child1()
obj1.greet()        # Output: Hello from Parent
obj1.greet_child1() # Output: Hello from Child1

obj2 = Child2()
obj2.greet()        # Output: Hello from Parent
obj2.greet_child2() # Output: Hello from Child2
5. Hybrid Inheritance
Definition: A combination of two or more types of inheritance.
Example:
python

class Parent:
    def greet(self):
        print("Hello from Parent")

class Child1(Parent):
    def greet_child1(self):
        print("Hello from Child1")

class Child2(Parent):
    def greet_child2(self):
        print("Hello from Child2")

class GrandChild(Child1, Child2):
    def greet_grandchild(self):
        print("Hello from GrandChild")

obj = GrandChild()
obj.greet()           # Output: Hello from Parent
obj.greet_child1()    # Output: Hello from Child1
obj.greet_child2()    # Output: Hello from Child2
obj.greet_grandchild() # Output: Hello from GrandChild
Example of Multiple Inheritance
python

class Animal:
    def eat(self):
        print("This animal eats food.")

class Bird:
    def fly(self):
        print("This bird can fly.")

class Bat(Animal, Bird):  # Bat inherits from both Animal and Bird
    def sound(self):
        print("The bat makes a screeching sound.")

# Example usage
bat = Bat()
bat.eat()       # Output: This animal eats food.
bat.fly()       # Output: This bird can fly.
bat.sound()     # Output: The bat makes a screeching sound.

//Ans 7
In Python, the Method Resolution Order (MRO) is the order in which Python looks for a method or attribute in a hierarchy of classes during inheritance. It determines the sequence of classes to be searched when calling a method or accessing an attribute in the context of multiple or hybrid inheritance.

Python uses the C3 Linearization Algorithm (used by new-style classes in Python 3) to determine the MRO. This ensures:

Depth-first search with overrides: The search prioritizes the nearest classes in the hierarchy.
Left-to-right precedence: For multiple inheritance, the order of the parent classes in the declaration matters.
No ambiguity: Avoids conflicts in case of diamond inheritance.
How to Retrieve MRO Programmatically?
You can retrieve the MRO using:

The .__mro__ attribute of a class.
The inspect.getmro() function from the inspect module.
The help() function for detailed class information.
Examples
Using .__mro__

python

class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(C.__mro__)
# Output: (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
Using inspect.getmro()

python

import inspect

class A:
    pass

class B(A):
    pass

class C(B):
    pass

print(inspect.getmro(C))
# Output: (<class '__main__.C'>, <class '__main__.B'>, <class '__main__.A'>, <class 'object'>)
Using help()

python

class A:
    pass

class B(A):
    pass

class C(B):
    pass

help(C)
# Displays detailed information, including the MRO.
Example with Multiple Inheritance
python

class A:
    def method(self):
        print("Method in A")

class B:
    def method(self):
        print("Method in B")

class C(A, B):  # Multiple inheritance
    pass

c = C()
c.method()  # Output: Method in A

print(C.__mro__)
# Output: (<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>, <class 'object'>)
In this example:

The MRO is determined as [C, A, B, object], so Python finds method in A before B.
Key Points
Order of Search: MRO respects the order of classes declared during inheritance.
C3 Linearization: Ensures consistency and avoids ambiguity.
Diamond Problem: MRO resolves conflicts in diamond inheritance scenarios, ensuring each class is visited once.

// Ans 8
Here’s how we can create an abstract base class Shape and implement its area() method in subclasses Circle and Rectangle:

Code Example
python

from abc import ABC, abstractmethod
import math

# Abstract Base Class
class Shape(ABC):
    @abstractmethod
    def area(self):
        '''Calculate and return the area of the shape.'''
        pass

# Subclass: Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius**2

# Subclass: Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Example Usage
circle = Circle(5)
print(f"Area of Circle: {circle.area():.2f}")  # Output: Area of Circle: 78.54

rectangle = Rectangle(4, 6)
print(f"Area of Rectangle: {rectangle.area()}")  # Output: Area of Rectangle: 24
Explanation
Abstract Base Class (Shape):

The Shape class inherits from ABC (Abstract Base Class) and defines an abstract method area() using the @abstractmethod decorator.
Abstract methods must be implemented in subclasses.
Subclass Circle:

Implements the area() method to calculate the area of a circle using the formula:
Area
=
𝜋
⋅
𝑟
2
Area=π⋅r
2

The radius is provided during initialization.
Subclass Rectangle:

Implements the area() method to calculate the area of a rectangle using the formula:
Area
=
width
⋅
height
Area=width⋅height
Width and height are provided during initialization.
Key Points
The @abstractmethod ensures that the subclasses cannot be instantiated unless all abstract methods are implemented.
Attempting to instantiate Shape or a subclass without implementing area() will raise a TypeError.
This structure enforces consistency across all Shape subclasses.

// Ans 9
Here’s how we can demonstrate polymorphism by creating a function that works with different shape objects:

Code Example
python

from abc import ABC, abstractmethod
import math

# Abstract Base Class
class Shape(ABC):
    @abstractmethod
    def area(self):
        '''Calculate and return the area of the shape.'''
        pass

# Subclass: Circle
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    def area(self):
        return math.pi * self.radius**2

# Subclass: Rectangle
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

# Function demonstrating polymorphism
def print_area(shape):
    '''
    Accepts a Shape object and prints its area.
    :param shape: An object of a subclass of Shape
    '''
    print(f"The area is: {shape.area():.2f}")

# Example Usage
circle = Circle(5)
rectangle = Rectangle(4, 6)

print_area(circle)     # Output: The area is: 78.54
print_area(rectangle)  # Output: The area is: 24.00
Explanation
Polymorphism in Action:

The function print_area() accepts an argument of type Shape (or any of its subclasses).
It calls the area() method on the provided object without knowing the specific type (either Circle or Rectangle).
Each subclass has its own implementation of area(), and Python dynamically resolves the appropriate method based on the object type.
Behavior:

For a Circle object, the Circle.area() method is invoked.
For a Rectangle object, the Rectangle.area() method is invoked.
Key Principle:

The same interface (area() method) is used for different objects, showcasing polymorphism.
Output

The area is: 78.54
The area is: 24.00
This approach highlights how polymorphism allows functions to operate on objects of different types seamlessly.

// Ans 10
Here’s an implementation of a BankAccount class demonstrating encapsulation:

Code Example
python

class BankAccount:
    def __init__(self, account_number, initial_balance=0):
        # Private attributes
        self.__account_number = account_number
        self.__balance = initial_balance

    # Public method to deposit money
    def deposit(self, amount):
        if amount > 0:
            self.__balance += amount
            print(f"Deposited: ${amount:.2f}")
        else:
            print("Deposit amount must be positive.")

    # Public method to withdraw money
    def withdraw(self, amount):
        if amount > 0:
            if amount <= self.__balance:
                self.__balance -= amount
                print(f"Withdrew: ${amount:.2f}")
            else:
                print("Insufficient funds.")
        else:
            print("Withdrawal amount must be positive.")

    # Public method to check balance
    def check_balance(self):
        print(f"Balance: ${self.__balance:.2f}")

    # Public method to get account number
    def get_account_number(self):
        return self.__account_number

# Example Usage
account = BankAccount(account_number="12345678", initial_balance=1000)

# Interacting with the account
account.check_balance()       # Output: Balance: $1000.00
account.deposit(500)          # Output: Deposited: $500.00
account.check_balance()       # Output: Balance: $1500.00
account.withdraw(200)         # Output: Withdrew: $200.00
account.check_balance()       # Output: Balance: $1300.00
account.withdraw(2000)        # Output: Insufficient funds.
print(account.get_account_number())  # Output: 12345678
Explanation
Private Attributes:

The __balance and __account_number attributes are private (indicated by the double underscore __).
They cannot be accessed directly outside the class, ensuring data encapsulation.
Public Methods:

deposit(amount): Adds a positive amount to the balance.
withdraw(amount): Deducts a positive amount if sufficient funds are available.
check_balance(): Prints the current balance.
get_account_number(): Returns the account number.
Encapsulation:

Direct access to the attributes is restricted, ensuring controlled access and preventing accidental modifications.
Access and modification of private attributes are done through public methods.
Output
bash
Copy code
Balance: $1000.00
Deposited: $500.00
Balance: $1500.00
Withdrew: $200.00
Balance: $1300.00
Insufficient funds.
12345678
This design ensures proper control over sensitive data (balance and account_number) and provides a secure interface for interacting with the BankAccount class.

//Ans 11
Certainly! Overriding the __str__ and __add__ magic methods in a class allows you to customize the behavior of your objects when they are converted to a string and when they are added together, respectively. Here's an example of a class that overrides these methods:

Code Example
python
class CustomNumber:
    def __init__(self, value):
        self.value = value

    def __str__(self):
        # Customizing the string representation of the object
        return f"CustomNumber({self.value})"

    def __add__(self, other):
        # Defining how two CustomNumber objects should be added
        if isinstance(other, CustomNumber):
            return CustomNumber(self.value + other.value)
        return NotImplemented

# Example usage
num1 = CustomNumber(10)
num2 = CustomNumber(20)

# Using __str__ method
print(num1)  # Outputs: CustomNumber(10)

# Using __add__ method
result = num1 + num2
print(result)  # Outputs: CustomNumber(30)
Explanation
__init__ Method:

Initializes the CustomNumber object with a value.

__str__ Method:

Overrides the default string representation of the object. When print() or str() is called on the object, this method is invoked.

In this example, it returns a custom string representation: CustomNumber(10).

__add__ Method:

Overrides the addition operator (+). This method is called when two CustomNumber objects are added.

Checks if the other operand is an instance of CustomNumber. If so, it returns a new CustomNumber object with the sum of their values.

If the other operand is not an instance of CustomNumber, it returns NotImplemented.

Benefits and Usage
__str__ Method: Customizing the string representation of objects makes it easier to debug and log, providing a human-readable output.

__add__ Method: Defining custom behavior for the addition operator allows you to control how objects of your class should be combined or added, providing flexibility for mathematical or logical operations.

// Ans 12)

 A decorator is a powerful tool in Python that allows you to modify the behavior of a function or method. To create a decorator that measures and prints the execution time of a function, you can use the time module. Here’s how you can do it:

Code
python
import time

def measure_time(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"Execution time of {func.__name__}: {execution_time:.4f} seconds")
        return result
    return wrapper

# Example usage
@measure_time
def example_function(n):
    sum = 0
    for i in range(n):
        sum += i
    return sum

# Call the decorated function
result = example_function(1000000)
Explanation
Import time Module: The time module provides various time-related functions.

Decorator Definition:

measure_time(func): The decorator function takes a function func as an argument.

wrapper(*args, **kwargs): The inner function wrapper takes any arguments and keyword arguments that the original function might take.

start_time = time.time(): Records the start time before calling the function.

result = func(*args, **kwargs): Calls the original function and stores the result.

end_time = time.time(): Records the end time after the function has completed.

execution_time = end_time - start_time: Calculates the total execution time.

print(f"Execution time of {func.__name__}: {execution_time:.4f} seconds"): Prints the execution time to the console.

return result: Returns the result of the original function.

Decorator Usage:

The @measure_time decorator is applied to example_function, which sums up numbers from 0 to n-1.

When example_function is called, the decorator prints the execution time.

Output
The execution time will be printed to the console whenever the decorated function is called.

//Ans 13)
The Diamond Problem is a well-known issue in multiple inheritance where a class inherits from two classes that both inherit from a common superclass. This creates a "diamond-shaped" inheritance structure. The problem arises when there are ambiguities in the inheritance hierarchy, especially if the common superclass has methods or attributes that are redefined in the intermediate classes.

Diamond Problem Example
Consider the following class hierarchy:
     A
    / \
   B   C
    \ /
     D
Here, D inherits from both B and C, which in turn both inherit from A. If class A has a method that B and C override, and then D calls that method, there is ambiguity about which version of the method should be called.

Example in Python
python
class A:
    def method(self):
        print("Method from A")

class B(A):
    def method(self):
        print("Method from B")

class C(A):
    def method(self):
        print("Method from C")

class D(B, C):
    pass

d = D()
d.method()  # Which method is called?
Resolution in Python
Python uses the C3 linearization algorithm (also known as the Method Resolution Order or MRO) to resolve the Diamond Problem. The MRO ensures that each class appears only once in the hierarchy and in a consistent order. Python's super() function is also designed to work with this linearized order.

MRO in Action
python
# You can inspect the MRO of a class using the __mro__ attribute or the mro() method
print(D.mro())
Output
[<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
In this example, D's MRO is [D, B, C, A, object]. When d.method() is called, Python will first look for the method in D, then B, then C, and finally A.

Calling super()
If we modify D to explicitly call super():

python
class D(B, C):
    def method(self):
        super().method()

d = D()
d.method()  # Outputs: Method from B
Here, super().method() in D will follow the MRO and call the method from B.

Conclusion
The Diamond Problem can introduce ambiguity in multiple inheritance, but Python resolves it using the MRO, ensuring a consistent and predictable order of method resolution. This helps in maintaining clear and manageable code, even with complex inheritance hierarchies.

// Ans 14)
class InstanceCounter:
    count = 0  # Class variable to keep track of the number of instances

    def __init__(self):
        # Increment the instance count when a new instance is created
        InstanceCounter.count += 1

    @classmethod
    def get_instance_count(cls):
        # Class method to access the instance count
        return cls.count

# Example usage
instance1 = InstanceCounter()
instance2 = InstanceCounter()
instance3 = InstanceCounter()

print(InstanceCounter.get_instance_count())  # Outputs: 3

Explanation
Class Variable:

count = 0: A class variable count is defined to keep track of the number of instances.

__init__ Method:

InstanceCounter.count += 1: Increments the count variable each time a new instance of InstanceCounter is created.

Class Method:

@classmethod: The get_instance_count method is decorated with @classmethod, which means it can access class variables and other class methods.

def get_instance_count(cls): Defines the class method. The cls parameter represents the class itself.

return cls.count: Returns the current value of the count variable.

Usage
Creating instances of InstanceCounter will automatically increment the count.

Calling InstanceCounter.get_instance_count() returns the total number of instances created so far.

Output
This will output:

python
3
This approach ensures that the class keeps an accurate count of the number of instances created.

//Ans 15)
class YearChecker:
    @staticmethod
    def is_leap_year(year):
        # Check if the year is a leap year
        if (year % 4 == 0 and year % 100 != 0) or (year % 400 == 0):
            return True
        return False

# Example usage
print(YearChecker.is_leap_year(2020))  # Outputs: True
print(YearChecker.is_leap_year(1900))  # Outputs: False
print(YearChecker.is_leap_year(2000))  # Outputs: True
print(YearChecker.is_leap_year(2021))  # Outputs: False

Explanation
Class Definition: YearChecker is defined as the class.

Static Method:

@staticmethod: Decorator to define is_leap_year as a static method. Static methods do not operate on instances of the class and do not modify class state.

def is_leap_year(year): Defines the static method that takes a year as input.

Leap Year Logic:

The method checks if the year is divisible by 4 but not by 100, or if it is divisible by 400. If either condition is true, the year is a leap year.

The method returns True if the year is a leap year, otherwise it returns False.

Usage
The static method is_leap_year can be called on the class itself without creating an instance of the class.

Output
This will output:

python
True
False
True
False
This class method allows you to easily check if any given year is a leap year.
"""